//
// Created by bddwy on 2021/12/15.
//

#include "RVO.h"
define r 0.2
define dis 3
/**
 * @brief Reciprocal Velocity Obstacle Algorithm
 * @param v The target velocity of all robots, generated by previous planning algorithm.
 * @param theta The target angle of all robots, generated by previous planning algorithm.
 * @return None. The input parameter theta has been modified.
 */
void RVO(const Eigen::VectorXd& x,const Eigen::VectorXd& y,const Eigen::VectorXd& v, Eigen::VectorXd& theta){

    double z[ROBOT_NUM][ROBOT_NUM][2] = {0}; //The relative position
    double u[ROBOT_NUM][ROBOT_NUM][2] = {0}; //The relative velosity
    double d[ROBOT_NUM][ROBOT_NUM] = {0}; //The minimum distance of center

    /**
     * Initialize the tables
     */
    for(auto i = 0; i < ROBOT_NUM; i++){
        for(auto j = 0; j < ROBOT_NUM; j++){
            z[i][j][0] = x(j)-x(i);
            z[i][j][1] = y(j)-y(i);
            u[i][j][0] = v(j)*cot(theta(j))-v(i)*cot(theta(i));
            u[i][j][1] = v(j)*tan(theta(j))-v(i)*tan(theta(i));
            d[i][j] = (u[i][j][0] *z[i][j][1]-u[i][j][1] *z[i][j][0])/sqrt(u[i][j][0]*u[i][j][0]+u[i][j][1]*u[i][j][1]);
        }
    }

    /**
     *
     */
    for(auto i = 0; i < ROBOT_NUM; i++){
        for(auto j = 0; j < ROBOT_NUM; j++){
            if( (r>Abs(d[i][j]))\
                && \
                (u[i][j][0] *z[i][j][0]+u[i][j][1] *z[i][j][1]<0) \
                && \
                (sqrt(z[i][j][0]*z[i][j][0]+z[i][j][1]*z[i][j][1])<dis)){
                theta(i) += d[i][j] / 2 * sqrt(z[i][j][0]*z[i][j][0]+z[i][j][1]*z[i][j][1]);
            }
        }
    }
}

/**
 * @brief Velocity Obstacle Algorithm
 * @param v The target velocity of all robots, generated by previous planning algorithm.
 * @param theta The target angle of all robots, generated by previous planning algorithm.
 * @return None. The input parameter theta has been modified.
 */
void VO(const Eigen::VectorXd& x,const Eigen::VectorXd& y,const Eigen::VectorXd& v, Eigen::VectorXd& theta){

    double z[ROBOT_NUM][OBSTACLE_NUM][2] = {0}; //The relative position
    double d[ROBOT_NUM][OBSTACLE_NUM] = {0}; //The minimum distance of center

    /**
     * Initialize the tables
     */
    for(auto i = 0; i < ROBOT_NUM; i++){
        for(auto j = 0; j < OBSTACLE_NUM; j++){
            z[i][j][0] = x(j)-x(i);
            z[i][j][1] = y(j)-y(i);
            d[i][j] = (v(i)*cot(theta(j)) *z[i][j][1]--v(i)*tan(theta(i)) *z[i][j][0])/v(i);
        }
    }

    for(auto i = 0; i < ROBOT_NUM; i++){
        for(auto j = 0; j < OBSTACLE_NUM; j++){
            if( (r>Abs(d[i][j]))\
                && \
                (v(i)*cot(theta(j)) *z[i][j][0]+u[i][j][1] *z[i][j][1]<0) \
                && \
                (sqrt(z[i][j][0]*z[i][j][0]+z[i][j][1]*z[i][j][1])<dis)){
                theta(i) += d[i][j] / v(i);
            }
        }
    }
}

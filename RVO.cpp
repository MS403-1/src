//
// Created by bddwy on 2021/12/15.
//

#include "RVO.h"

/**
 * @brief Reciprocal Velocity Obstacle Algorithm
 * @param v The target velocity of all robots, generated by previous planning algorithm.
 * @param theta The target angle of all robots, generated by previous planning algorithm.
 * @return None. The input parameter theta has been modified.
 */
void RVO(const Eigen::VectorXd& v, Eigen::VectorXd& theta){

    double z[ROBOT_NUM][ROBOT_NUM][2] = {0}; //The relative position
    double u[ROBOT_NUM][ROBOT_NUM][2] = {0}; //The relative velosity
    double d[ROBOT_NUM][ROBOT_NUM] = {0}; //The minimum distance of center

    /**
     * Initialize the tables
     */
    for(auto i = 0; i < ROBOT_NUM; i++){
        for(auto j = 0; j < ROBOT_NUM; j++){
            z[i][j][0] = ;
            z[i][j][1] = ;
            v[i][j][0] = ;
            v[i][j][1] = ;
            d[i][j] = ;
        }
    }

    /**
     *
     */
    for(auto i = 0; i < ROBOT_NUM; i++){
        for(auto j = 0; j < ROBOT_NUM; j++){
            if( ()\
                && \
                () \
                && \
                ()){
                theta(i) += d[i][j] / 2 * sqrt();
            }
        }
    }
}

/**
 * @brief Velocity Obstacle Algorithm
 * @param v The target velocity of all robots, generated by previous planning algorithm.
 * @param theta The target angle of all robots, generated by previous planning algorithm.
 * @return None. The input parameter theta has been modified.
 */
void VO(const Eigen::VectorXd& v, Eigen::VectorXd& theta){

    double z[ROBOT_NUM][OBSTACLE_NUM][2] = {0}; //The relative position
    double d[ROBOT_NUM][OBSTACLE_NUM] = {0}; //The minimum distance of center

    /**
     * Initialize the tables
     */
    for(auto i = 0; i < ROBOT_NUM; i++){
        for(auto j = 0; j < OBSTACLE_NUM; j++){
            z[i][j][0] = ;
            z[i][j][1] = ;
            d[i][j] = ;
        }
    }

    for(auto i = 0; i < ROBOT_NUM; i++){
        for(auto j = 0; j < OBSTACLE_NUM; j++){
            if( ()\
                && \
                () \
                && \
                ()){
                theta(i) += d[i][j] / sqrt();
            }
        }
    }
}
